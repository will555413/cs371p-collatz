        -:    0:Source:Collatz.c++
        -:    0:Graph:Collatz.gcno
        -:    0:Data:Collatz.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// ----------------------------
        -:    2:// projects/collatz/Collatz.c++
        -:    3:// Copyright (C) 2015
        -:    4:// Glenn P. Downing
        -:    5:// ----------------------------
        -:    6:
        -:    7:// --------
        -:    8:// includes
        -:    9:// --------
        -:   10:
        -:   11:#include <cassert>  // assert
        -:   12:#include <iostream> // endl, istream, ostream
        -:   13:#include <sstream>  // istringstream
        -:   14:#include <string>   // getline, string
        -:   15:#include <utility>  // make_pair, pair
        -:   16:
        -:   17:#include "Collatz.h"
        -:   18:
        -:   19:using namespace std;
        -:   20:
        -:   21:// global array that acts like a cache to store the calculated collatz value
        -:   22:int cache [3000001] = {};
        -:   23:
        -:   24:
        -:   25:// ------------
        -:   26:// collatz_read
        -:   27:// ------------
        -:   28:
function _Z12collatz_readRKSs called 9 returned 100% blocks executed 80%
        9:   29:pair<int, int> collatz_read (const string& s) {
        9:   30:    istringstream sin(s);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        -:   31:    int i;
        -:   32:    int j;
        9:   33:    sin >> i >> j;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
        9:   34:    return make_pair(i, j);}
call    0 returned 100%
call    1 returned 100%
call    2 never executed
        -:   35:
        -:   36:// ------------
        -:   37:// collatz_eval
        -:   38:// ------------
        -:   39:
function _Z12collatz_evalii called 16 returned 100% blocks executed 88%
       16:   40:int collatz_eval (int i, int j) {
        -:   41:    // assert: input validity check
       16:   42:    assert (i>0 && i<1000000);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
       16:   43:    assert (j>0 && j<1000000);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -:   44:
        -:   45:    // Input sorting: compare the inputs and set the larger on as end and the smaller one as start.
       16:   46:    int highest = 0, start = 0, end = 0;
       16:   47:    if(i==j)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:   48:    {
        4:   49:        start = i;
        4:   50:        end = i;
        -:   51:    }
       12:   52:    else if(i<j)
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        -:   53:    {
       10:   54:        start = (j/2+1>i) ? j/2+1 : i;
       10:   55:        end = j;
        -:   56:    }
        -:   57:    else
        -:   58:    {
        2:   59:        start = (i/2+1>j) ? i/2+1 : j;
        2:   60:        end = i;
        -:   61:    }
       16:   62:    cache[1] = 1;
        -:   63:    
        -:   64:    // iterate through all numbers between start and end
  1005452:   65:    for(; start<=end; start++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   66:    {
  1005436:   67:        int cycle = 0;
  1005436:   68:        cycle = collatz_iter(start);
call    0 returned 100%
        -:   69:
  1005436:   70:        if(start < 3000001 && cache[start] != 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        -:   71:        {
        2:   72:            cache[start] = cycle;
        -:   73:        }
        -:   74:        // cout<<"cycle of "<<start<<" = "<<cycle<<endl;
  1005436:   75:        if(highest<cycle)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
       70:   76:            highest = cycle;
        -:   77:    }
        -:   78:    // assert: output validity check
       16:   79:    assert (highest>0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       16:   80:    return highest;
        -:   81:    // return 1;
        -:   82:}
        -:   83:
        -:   84:// ------------
        -:   85:// collatz_iter
        -:   86:// ------------
        -:   87:
function _Z12collatz_iteri called 1005436 returned 100% blocks executed 90%
  1005436:   88:int collatz_iter (int i)
        -:   89:{
  1005436:   90:    int cycle = 0;
  1005436:   91:    unsigned int x = i;
 94918692:   92:    while(x>0)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -:   93:    {
 93913256:   94:        if(x < 3000001)
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
        -:   95:        {
 92087920:   96:            if(cache[x]!=0)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:   97:            {
  1005436:   98:                cycle += cache[x];
  1005436:   99:                return cycle;
        -:  100:            }
        -:  101:        }
 92907820:  102:        if(x & 1)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  103:        {
 46142698:  104:            x += (x >> 1) + 1;    
 46142698:  105:            cycle += 2;
        -:  106:        }
        -:  107:        else
        -:  108:        {
 46765122:  109:            x = x >> 1;
 46765122:  110:            cycle++;
        -:  111:        }
        -:  112:
        -:  113:    }
    #####:  114:    return cycle;
        -:  115:}
        -:  116:
        -:  117:// ------------
        -:  118:// collatz_recur
        -:  119:// ------------
        -:  120:
function _Z13collatz_recurj called 0 returned 0% blocks executed 0%
    #####:  121:int collatz_recur (unsigned int x)
        -:  122:{
    #####:  123:    if(x == 0)
branch  0 never executed
branch  1 never executed
        -:  124:    {
        -:  125:        // cout << "case [0]: return 0" << endl;
    #####:  126:        return 0;
        -:  127:    }
    #####:  128:    else if(x < 3000001)
branch  0 never executed
branch  1 never executed
        -:  129:    {
    #####:  130:        if(cache[x]!=0)
branch  0 never executed
branch  1 never executed
        -:  131:        {
        -:  132:            // cout << "case [cache found]: return cache["<< x << "]" << endl;
    #####:  133:            return cache[x];
        -:  134:        }
    #####:  135:        else if(x == 1)
branch  0 never executed
branch  1 never executed
        -:  136:        {
        -:  137:            // cout << "case [x<arr & x=1]: return 1" << endl;
    #####:  138:            return 1;
        -:  139:        }
    #####:  140:        else if(x & 1)
branch  0 never executed
branch  1 never executed
        -:  141:        {
        -:  142:            // cout << "case [x="<< x <<"<length]: recurr odd case" << endl;
    #####:  143:            return cache[x] = 1+collatz_recur(x*3+1);
call    0 never executed
        -:  144:        }
        -:  145:        else
        -:  146:        {
        -:  147:            // cout << "case [x="<< x <<"<length]: recurr even case" << endl;
    #####:  148:            return cache[x] = 1+collatz_recur(x/2);
call    0 never executed
        -:  149:        }
        -:  150:    }
    #####:  151:    else if(x & 1)
branch  0 never executed
branch  1 never executed
        -:  152:    {
        -:  153:        // cache[x] = 1+collatz(x*3+1);
        -:  154:        // cout << "case [x="<< x <<">length]: recurr odd case" << endl;
    #####:  155:        return 1+collatz_recur(x*3+1);
call    0 never executed
        -:  156:    }
        -:  157:    else
        -:  158:    {
        -:  159:        // cache[x] = 1+collatz(x/2);
        -:  160:        // cout << "case [x="<< x <<">length]: recurr even case" << endl;
    #####:  161:        return 1+collatz_recur(x/2);
call    0 never executed
        -:  162:    }
        -:  163:}
        -:  164:
        -:  165:// -------------
        -:  166:// collatz_print
        -:  167:// -------------
        -:  168:
function _Z13collatz_printRSoiii called 12 returned 100% blocks executed 100%
       12:  169:void collatz_print (ostream& w, int i, int j, int v) {
       12:  170:    w << i << " " << j << " " << v << endl;}
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
        -:  171:
        -:  172:// -------------
        -:  173:// collatz_solve
        -:  174:// -------------
        -:  175:
function _Z13collatz_solveRSiRSo called 2 returned 100% blocks executed 80%
        2:  176:void collatz_solve (istream& r, ostream& w) {
        2:  177:    string s;
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
       12:  178:    while (getline(r, s)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
call    3 returned 100%
branch  4 taken 100% (fallthrough)
branch  5 taken 0% (throw)
branch  6 taken 80%
branch  7 taken 20% (fallthrough)
        8:  179:        const pair<int, int> p = collatz_read(s);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
        8:  180:        const int            i = p.first;
        8:  181:        const int            j = p.second;
        8:  182:        const int            v = collatz_eval(i, j);
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0% (throw)
function _GLOBAL__sub_I_cache called 1 returned 100% blocks executed 100%
function _Z41__static_initialization_and_destruction_0ii called 1 returned 100% blocks executed 100%
       13:  183:        collatz_print(w, i, j, v);}}
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
call    5 returned 100%
branch  6 taken 100% (fallthrough)
branch  7 taken 0% (throw)
call    8 returned 100%
call    9 never executed
